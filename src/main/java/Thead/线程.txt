1.线程依赖于进程存在
2.进程：
    正在运行的程序，每一个进程都有自己的内存空间和系统资源。
3.多进程：
    同时做多件事情。多进程可提高CPU使用率，一个CPU在一时间点只能做一件事情（单核）。
    CPU----高效切换
4.线程：
    程序的执行单元，执行路径。同一个进程同一时间执行多个任务，这个任务就看做线程
5.多线程：
    提高应用程序的使用率
    多个进程在抢CPU的资源，某一个进程执行路径多，就可以有更高的几率抢到CPU的执行权。
    线程的执行有随机性
6.并行和并发
    并行：一个时间内同时运行多个程序。（逻辑）
    并发：一个时间点同时运行多个程序。（物理）
7.java程序的运行原理
    由java程序启动JVM,JVM相当于一个进程。
    进程又创建了一个主线程去调用main()方法
    JVM虚拟机的启动是多线程：原因是垃圾回收机制要先启动一个线程
8.java是不能直接调用系统功能的，java可以调用C/C++程序实现多线程程序
9.创建新线程有三种方法
    A:Thread 继承thread类;重写run()方法;创建对象;启动线程
    B:实现runable接口 自定义runable类；重写run()方法;创建runable类的对象；创建Thread对象，
     implements Runnable { public void run() {}}         runable imrun=new runable();                  Thread a=new Thread(imrun,"a");        
    C:
10.获取或设置线程线程名
    获取当前主线程的线程名  Thread.currentThread().getName()
    设置线程名字setName，有两种方法：
        setName():run(){  }中  setName("线程a");
        重写线程构造方法       thread2 my2 =new thread2("线程b");         thread2(){}    thread2(String name){        super.setName(name); }
11.线程调度
    分时调度：轮流使用
    抢占式调度：优先级高获取CPU时间片先对多一些
    getPriority() 获取线程优先级
    注意：线程默认优先级为5
    setPriority(int newPriority) 设置线程优先级(范围为1-10)
12.线程控制
    线程休眠sleep(long millis)在这个时间段 run(){}中    Thread.sleep(1000);
    进程加入join()等待该线程终止，让这个线程执行完毕，其他线程才能继续执行      main()方法中
    线程礼让yield() 暂停当前正在执行的线程，并执行其他线程。让多个线程的执行更和谐，但并不能保证一人一次
    后台线程setDaemon()将该线程标记为守护线程或用户线程，当运行的线程都是守护线程时，JVM退出。该方法必须在启动线程前运行          a.setDaemon(true);
    中断线程stop()[过时]
            interrupt() 把线程状态终止，并抛出InterruptException()
13.多线程，线程周期
    新建：创建进程对象
    就绪：有执行资格，没有执行权
    运行：有执行资格，有执行权
    阻塞：由于一些操作使其处于此状态，没有执行资格，没有执行权
    死亡：线程对象变成垃圾，等待被回收
14.对比实现多线程的方式
    通过接口方式，解决了单继承的局限性，更适合于相同程序的代码去处理同一个资源的情况
15.多线程访问同一个变量（延迟）
    CPU的一次操作必须是原子性的；随机性和延迟性
16.线程安全问题
    A:多线程环境
    B:共享数据
    C:多条语句操作共享数据
17.同步代码块的方式解决线程安全问题（同步机制）
    把多条语句操作共享数据的代码包成一个整体，让某个线程执行的时候，其他线程不能访问
    synchronized(对象){
    需要同步的代码
    }
    对象相当于一把锁











